@using Beep.OilandGas.ApiService.Models
@using Beep.OilandGas.Web.Services
@using MudBlazor
@implements IAsyncDisposable
@inject IProgressTrackingClient ProgressClient

<MudPaper Elevation="2" Class="pa-4 mb-4">
    <MudStack>
        <MudText Typo="Typo.h6">@Title</MudText>
        <MudText Typo="Typo.body2" Color="Color.Secondary">
            @(_operations.Count) operation(s) - @_completedCount completed, @_runningCount running, @_failedCount failed
        </MudText>

        <MudProgressLinear Value="@_overallProgress" 
                          Color="Color.Primary" 
                          Class="mb-2" />

        @foreach (var operation in _operations.Values)
        {
            <MudPaper Elevation="1" Class="pa-3 mb-2">
                <MudStack Row="true" AlignItems="AlignItems.Center" Justify="Justify.SpaceBetween">
                    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2">
                        @if (operation.IsComplete)
                        {
                            <MudIcon Icon="@(operation.HasError ? Icons.Material.Filled.Error : Icons.Material.Filled.CheckCircle)" 
                                   Color="@(operation.HasError ? Color.Error : Color.Success)" />
                        }
                        else
                        {
                            <MudProgressCircular Size="Size.Small" 
                                               Indeterminate="true" 
                                               Class="mr-2" />
                        }
                        
                        <MudText Typo="Typo.body2">
                            @operation.OperationType - @operation.StatusMessage
                        </MudText>
                    </MudStack>

                    <MudChip T="string" Size="Size.Small" 
                           Color="@GetStatusColor(operation)" 
                           Variant="Variant.Text">
                        @GetStatusText(operation)
                    </MudChip>
                </MudStack>

                @if (!operation.IsComplete)
                {
                    <MudProgressLinear Value="@operation.ProgressPercentage" 
                                      Color="Color.Primary" 
                                      Class="mt-2" 
                                      Size="Size.Small" />
                    
                    @if (operation.TotalItems.HasValue)
                    {
                        <MudText Typo="Typo.caption" Color="Color.Secondary">
                            @operation.ItemsProcessed / @operation.TotalItems items
                        </MudText>
                    }
                }

                @if (operation.HasError && !string.IsNullOrEmpty(operation.ErrorMessage))
                {
                    <MudExpansionPanels Class="mt-2">
                        <MudExpansionPanel Text="Error Details">
                            <MudText Typo="Typo.body2" Color="Color.Error">
                                @operation.ErrorMessage
                            </MudText>
                        </MudExpansionPanel>
                    </MudExpansionPanels>
                }
            </MudPaper>
        }
    </MudStack>
</MudPaper>

@code {
    [Parameter] public Dictionary<string, ProgressUpdate> Operations { get; set; } = new();
    [Parameter] public string Title { get; set; } = "Multiple Operations";
    [Parameter] public EventCallback<ProgressUpdate> OnOperationComplete { get; set; }

    private Dictionary<string, ProgressUpdate> _operations = new();
    private int _completedCount = 0;
    private int _runningCount = 0;
    private int _failedCount = 0;
    private int _overallProgress = 0;
    private bool _isDisposed = false;

    protected override void OnParametersSet()
    {
        _operations = Operations;
        UpdateCounts();
    }

    protected override async Task OnInitializedAsync()
    {
        ProgressClient.OnProgressUpdate += HandleProgressUpdate;
        await ProgressClient.ConnectAsync();
        
        // Join all operation groups
        foreach (var operationId in _operations.Keys)
        {
            await ProgressClient.JoinOperationAsync(operationId);
        }
    }

    private void UpdateCounts()
    {
        _completedCount = _operations.Values.Count(o => o.IsComplete);
        _runningCount = _operations.Values.Count(o => !o.IsComplete);
        _failedCount = _operations.Values.Count(o => o.IsComplete && o.HasError);
        _overallProgress = _operations.Values.Any() 
            ? (int)_operations.Values.Average(o => o.ProgressPercentage)
            : 0;
    }

    private async void HandleProgressUpdate(ProgressUpdate progress)
    {
        if (!_operations.ContainsKey(progress.OperationId))
            return;

        _operations[progress.OperationId] = progress;
        UpdateCounts();
        
        await InvokeAsync(StateHasChanged);

        if (progress.IsComplete)
        {
            await OnOperationComplete.InvokeAsync(progress);
        }
    }

    private Color GetStatusColor(ProgressUpdate operation)
    {
        if (operation.IsComplete)
        {
            return operation.HasError ? Color.Error : Color.Success;
        }
        return Color.Primary;
    }

    private string GetStatusText(ProgressUpdate operation)
    {
        if (operation.IsComplete)
        {
            return operation.HasError ? "Failed" : "Completed";
        }
        return "Running";
    }

    public async ValueTask DisposeAsync()
    {
        if (_isDisposed)
            return;

        _isDisposed = true;
        ProgressClient.OnProgressUpdate -= HandleProgressUpdate;
        
        foreach (var operationId in _operations.Keys)
        {
            await ProgressClient.LeaveOperationAsync(operationId);
        }
    }
}
