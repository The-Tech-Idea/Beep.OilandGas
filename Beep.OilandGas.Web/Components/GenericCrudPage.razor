@using System.Text
@using System.Reflection
@using System.Globalization
@using Beep.OilandGas.PPDM39.Core.Tree
@using Beep.OilandGas.PPDM39.Core.Metadata
@using MudBlazor
@using Beep.OilandGas.Web.Components.Shared

@if (TableNode == null)
{
    <MudAlert Severity="Severity.Warning">No table selected. Please select a table from the tree.</MudAlert>
}
else
{
<MudContainer MaxWidth="MaxWidth.False" Class="pa-4">
    <MudText Typo="Typo.h5" Class="mb-4">@GetTableDisplayName()</MudText>
    
    <MudButtonGroup Class="mb-4">
        <MudButton Variant="Variant.Filled" 
                   Color="Color.Primary" 
                   StartIcon="@Icons.Material.Filled.Add"
                   OnClick="CreateNew">
            New Record
        </MudButton>
        <MudButton Variant="Variant.Outlined" 
                   Color="Color.Primary" 
                   StartIcon="@Icons.Material.Filled.Refresh"
                   OnClick="LoadData">
            Refresh
        </MudButton>
        <MudButton Variant="Variant.Outlined" 
                   Color="Color.Success" 
                   StartIcon="@Icons.Material.Filled.FileDownload"
                   OnClick="ExportToCsv"
                   Disabled="@(_data == null || !_data.Any())">
            Export CSV
        </MudButton>
        <MudButton Variant="Variant.Outlined" 
                   Color="Color.Success" 
                   StartIcon="@Icons.Material.Filled.Upload"
                   OnClick="ShowImportDialog">
            Import CSV
        </MudButton>
    </MudButtonGroup>

    @if (_isLoading)
    {
        <MudProgressLinear Color="Color.Primary" Indeterminate="true" Class="my-4" />
    }

    @if (_showEditForm && _editingRecord != null)
    {
        <MudCard Class="mb-4">
            <MudCardContent>
                <MudText Typo="Typo.h6" Class="mb-3">
                    @(_editingRecord == null ? "Create New Record" : "Edit Record")
                </MudText>
                <PPDMEntityForm Entity="@_editingRecord"
                               TableMetadata="@_tableMetadata"
                               DefaultValues="@_defaultValues"
                               GetDefaultValue="@((fieldName) => GetDefaultValue(fieldName))"
                               FieldOptions="@_foreignKeyFieldOptions"
                               OnValidSubmit="SaveRecord"
                               OnCancel="CancelEdit"
                               ShowCancel="true"
                               SubmitText="Save"
                               CancelText="Cancel" />
            </MudCardContent>
        </MudCard>
    }

    @if (_data != null && _data.Any())
    {
        <PPDMDataGrid Items="@_data"
                     Title="@GetTableDisplayName()"
                     TableMetadata="@_tableMetadata"
                     IsLoading="@_isLoading"
                     ShowActions="true"
                     ShowExport="true"
                     ShowSearch="true"
                     ShowPagination="true"
                     MaxDisplayColumns="10"
                     OnEdit="EditRecord"
                     OnView="ViewRecord"
                     OnDelete="DeleteRecord"
                     OnExport="ExportToCsv">
            <ToolbarActions>
                <MudButton Variant="Variant.Outlined" 
                           Color="Color.Success"
                           StartIcon="@Icons.Material.Filled.Upload"
                           OnClick="ShowImportDialog"
                           Size="Size.Small">
                    Import CSV
                </MudButton>
            </ToolbarActions>
        </PPDMDataGrid>
    }
    else if (!_isLoading)
    {
        <MudText Typo="Typo.body1" Class="pa-4">No records found.</MudText>
    }
</MudContainer>
}

@code {
    [Parameter] public PPDMTreeNode? TableNode { get; set; }

    private List<object>? _data;
    private object? _editingRecord;
    private bool _isLoading = false;
    private bool _showEditForm = false;
    private string _searchString = string.Empty;
    private PPDMTableMetadata? _tableMetadata;
    private Dictionary<string, object>? _defaultValues;
    private Dictionary<string, Dictionary<string, string>>? _foreignKeyFieldOptions;

    protected override async Task OnParametersSetAsync()
    {
        try
        {
            if (TableNode != null)
            {
                Console.WriteLine($"GenericCrudPage: OnParametersSetAsync - Table: {TableNode?.Text ?? "Unknown"}, Type: {TableNode?.NodeType}");
                
                // Reset state when table changes
                _data = null;
                _editingRecord = null;
                _showEditForm = false;
                _tableMetadata = null;
                
                await LoadTableMetadata();
                
                if (_tableMetadata != null)
                {
                    Console.WriteLine($"GenericCrudPage: Metadata loaded - Table: {_tableMetadata.TableName}");
                    await LoadData();
                }
                else
                {
                    Console.WriteLine($"GenericCrudPage: WARNING - No metadata found for table node: {TableNode?.Text ?? "Unknown"}");
                    Snackbar?.Add($"Could not load metadata for table: {TableNode?.Text ?? "Unknown"}", Severity.Warning);
                }
                
                StateHasChanged();
            }
            else
            {
                Console.WriteLine($"GenericCrudPage: OnParametersSetAsync - TableNode is null");
                _data = null;
                _tableMetadata = null;
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"GenericCrudPage: Exception in OnParametersSetAsync: {ex.Message}");
            Console.WriteLine($"GenericCrudPage: Stack trace: {ex.StackTrace}");
            Snackbar?.Add($"Error loading table: {ex.Message}", Severity.Error);
            _data = null;
            _tableMetadata = null;
            StateHasChanged();
        }
    }

    private async Task LoadTableMetadata()
    {
        try
        {
            if (TableNode?.Data != null && TableNode.Data.TryGetValue("TableMetadata", out var metadata))
            {
                _tableMetadata = metadata as PPDMTableMetadata;
                Console.WriteLine($"LoadTableMetadata: Found metadata in node data - {_tableMetadata?.TableName}");
            }
            
            // Fallback: Try to get table name from node
            if (_tableMetadata == null && TableNode != null)
            {
                var tableName = TableNode.Text ?? string.Empty;
                if (TableNode.Data != null && TableNode.Data.TryGetValue("TableName", out var tableNameObj))
                {
                    tableName = tableNameObj?.ToString() ?? tableName;
                }
                
                Console.WriteLine($"LoadTableMetadata: Fallback - trying to get metadata for table: {tableName}");
                
                if (!string.IsNullOrWhiteSpace(tableName))
                {
                    // The metadata should be in the node, but if it's not, we can't easily get it here
                    // The tree builder should have set it. Let's log what we have in the node.
                    if (TableNode.Data != null)
                    {
                        Console.WriteLine($"LoadTableMetadata: Node data keys: {string.Join(", ", TableNode.Data.Keys)}");
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"LoadTableMetadata: Exception - {ex.Message}");
            _tableMetadata = null;
        }
    }

    private async Task LoadData()
    {
        if (TableNode == null || _tableMetadata == null) return;

        _isLoading = true;
        try
        {
            var tableName = _tableMetadata?.TableName;
            if (string.IsNullOrWhiteSpace(tableName))
            {
                Console.WriteLine("LoadData: Table name is null or empty");
                _data = new List<object>();
                return;
            }
            
            var apiEndpoint = GetApiEndpoint(tableName);
            
            if (ApiClient != null)
            {
                _data = await ApiClient.GetAsync<List<object>>($"/api/{apiEndpoint}");
            }
            else
            {
                Console.WriteLine("LoadData: ApiClient is null");
                _data = new List<object>();
            }
            
            if (_data == null)
            {
                _data = new List<object>();
                Snackbar?.Add($"No data returned for table: {tableName}", Severity.Info);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"LoadData: Exception - {ex.Message}");
            Console.WriteLine($"LoadData: Stack trace: {ex.StackTrace}");
            Snackbar?.Add($"Error loading data for {_tableMetadata?.TableName ?? "table"}: {ex.Message}", Severity.Error);
            _data = new List<object>();
        }
        finally
        {
            _isLoading = false;
        }
    }

    private async Task CreateNew()
    {
        Type? entityType = null;
        if (_tableMetadata != null && !string.IsNullOrEmpty(_tableMetadata.EntityTypeName))
        {
            // Get the type from the entity type name
            var assembly = typeof(Beep.OilandGas.PPDM39.Models.WELL).Assembly;
            entityType = assembly.GetType($"Beep.OilandGas.PPDM39.Models.{_tableMetadata.EntityTypeName}") 
                        ?? Type.GetType(_tableMetadata.EntityTypeName);
        }
        _editingRecord = Activator.CreateInstance(entityType ?? typeof(object));
        await PrepareDefaultsAndForeignKeyOptions();
        _showEditForm = true;
    }
    
    private async Task PrepareDefaultsAndForeignKeyOptions()
    {
        // Prepare default values dictionary
        _defaultValues = new Dictionary<string, object>();
        if (_editingRecord != null)
        {
            var properties = _editingRecord.GetType().GetProperties(BindingFlags.Public | BindingFlags.Instance);
            foreach (var prop in properties)
            {
                if (prop.CanWrite)
                {
                    var currentValue = prop.GetValue(_editingRecord);
                    if (currentValue == null || (currentValue is string str && string.IsNullOrWhiteSpace(str)))
                    {
                        var defaultValue = GetDefaultValue(prop.Name);
                        if (defaultValue != null)
                        {
                            var convertedValue = ConvertDefaultValue(defaultValue, prop.PropertyType);
                            if (convertedValue != null)
                            {
                                _defaultValues[prop.Name] = convertedValue;
                                prop.SetValue(_editingRecord, convertedValue);
                            }
                        }
                    }
                }
            }
        }
        
        // Prepare foreign key options
        await PreloadForeignKeyOptions();
    }

    // This method is replaced by PrepareDefaultsAndForeignKeyOptions which works with PPDMEntityForm

    private async Task EditRecord(object record)
    {
        _editingRecord = record;
        await PreloadForeignKeyOptions();
        _defaultValues = null; // No defaults when editing existing record
        _showEditForm = true;
    }

    private async Task ViewRecord(object record)
    {
        // For now, viewing is the same as editing, but could be enhanced to show read-only view
        await EditRecord(record);
    }

    private async Task SaveRecord()
    {
        if (_editingRecord == null || _tableMetadata == null) return;

        try
        {
            var tableName = _tableMetadata.TableName;
            var apiEndpoint = GetApiEndpoint(tableName);
            var recordId = GetRecordId(_editingRecord);

            if (string.IsNullOrEmpty(recordId))
            {
                // Create new - send full object
                await ApiClient.PostAsync<object, object>($"/api/{apiEndpoint}", _editingRecord);
                Snackbar.Add("Record created successfully", Severity.Success);
            }
            else
            {
                // Update existing - use record ID in URL or send full object
                // For composite keys, we might need to send the full object
                if (_tableMetadata.PrimaryKeyColumn.Contains(','))
                {
                    // Composite key - send full object
                    await ApiClient.PutAsync<object, object>($"/api/{apiEndpoint}", _editingRecord);
                }
                else
                {
                    // Single key - use ID in URL
                    await ApiClient.PutAsync<object, object>($"/api/{apiEndpoint}/{recordId}", _editingRecord);
                }
                Snackbar.Add("Record updated successfully", Severity.Success);
            }

            _showEditForm = false;
            _editingRecord = null;
            await LoadData();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error saving record: {ex.Message}", Severity.Error);
        }
    }

    private async Task DeleteRecord(object record)
    {
        if (_tableMetadata == null) return;

        var recordId = GetRecordId(record);
        if (string.IsNullOrEmpty(recordId)) return;

        var result = await DialogService.ShowMessageBox(
            "Confirm Delete",
            $"Are you sure you want to delete this record?",
            yesText: "Delete", cancelText: "Cancel");

        if (result == true)
        {
            try
            {
                var tableName = _tableMetadata.TableName;
                var apiEndpoint = GetApiEndpoint(tableName);
                
                // For composite keys, encode the ID or send in body
                if (_tableMetadata.PrimaryKeyColumn.Contains(','))
                {
                    // Composite key - send delete request with record in body or encoded ID
                    var encodedId = Uri.EscapeDataString(recordId);
                    await ApiClient.DeleteAsync($"/api/{apiEndpoint}/{encodedId}");
                }
                else
                {
                    // Single key
                    await ApiClient.DeleteAsync($"/api/{apiEndpoint}/{recordId}");
                }
                
                Snackbar.Add("Record deleted successfully", Severity.Success);
                await LoadData();
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Error deleting record: {ex.Message}", Severity.Error);
            }
        }
    }

    private void CancelEdit()
    {
        _showEditForm = false;
        _editingRecord = null;
    }

    private string GetTableDisplayName()
    {
        return TableNode?.Text ?? "Select a Table";
    }

    private string GetApiEndpoint(string tableName)
    {
        // Use generic PPDM39 data management endpoint for all tables
        // This allows any table to be accessed dynamically
        return $"ppdm39/tables/{tableName.ToLowerInvariant()}";
    }

    private string? GetRecordId(object record)
    {
        if (_tableMetadata?.PrimaryKeyColumn == null) return null;
        
        // Handle composite primary keys
        if (_tableMetadata.PrimaryKeyColumn.Contains(','))
        {
            var keyParts = _tableMetadata.PrimaryKeyColumn.Split(',', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries);
            var values = new List<string>();
            
            foreach (var keyPart in keyParts)
            {
                var prop = record.GetType().GetProperty(keyPart);
                var value = prop?.GetValue(record)?.ToString();
                if (string.IsNullOrEmpty(value))
                    return null; // Composite key incomplete
                values.Add(value);
            }
            
            return string.Join(",", values);
        }
        else
        {
            // Single primary key
            var prop = record.GetType().GetProperty(_tableMetadata.PrimaryKeyColumn);
            return prop?.GetValue(record)?.ToString();
        }
    }

    // These methods are no longer needed as they're handled by shared components
    // Keeping them for backward compatibility if referenced elsewhere
    private List<PropertyInfo> GetDisplayProperties()
    {
        if (_data == null || !_data.Any()) return new List<PropertyInfo>();
        
        var firstRecord = _data.First();
        return firstRecord.GetType()
            .GetProperties(BindingFlags.Public | BindingFlags.Instance)
            .Where(p => p.CanRead && !IsSystemProperty(p))
            .Take(10) // Limit to first 10 properties for display
            .ToList();
    }
    
    private bool IsSystemProperty(PropertyInfo prop)
    {
        var systemProps = new[] { "PPDM_GUID", "ROW_CREATED_BY", "ROW_CREATED_DATE", "ROW_CHANGED_BY", "ROW_CHANGED_DATE" };
        return systemProps.Contains(prop.Name, StringComparer.OrdinalIgnoreCase);
    }
    
    private string GetPropertyDisplayName(PropertyInfo prop)
    {
        return prop.Name.Replace("_", " ");
    }

    private object? GetPropertyValue(object? obj, string propertyName)
    {
        if (obj == null) return null;
        var prop = obj.GetType().GetProperty(propertyName);
        return prop?.GetValue(obj);
    }

    private void SetPropertyValue(object obj, string propertyName, object? value)
    {
        var prop = obj.GetType().GetProperty(propertyName);
        if (prop != null && prop.CanWrite)
        {
            prop.SetValue(obj, value);
        }
    }

    private void SetPropertyValueFromString(object obj, PropertyInfo prop, string value)
    {
        if (prop == null || !prop.CanWrite) return;
        
        try
        {
            object? convertedValue = null;
            if (prop.PropertyType == typeof(string))
            {
                convertedValue = value;
            }
            else if (prop.PropertyType == typeof(int) || prop.PropertyType == typeof(int?))
            {
                if (int.TryParse(value, out var intVal))
                    convertedValue = intVal;
            }
            else if (prop.PropertyType == typeof(decimal) || prop.PropertyType == typeof(decimal?))
            {
                if (decimal.TryParse(value, out var decVal))
                    convertedValue = decVal;
            }
            else if (prop.PropertyType == typeof(double) || prop.PropertyType == typeof(double?))
            {
                if (double.TryParse(value, out var dblVal))
                    convertedValue = dblVal;
            }
            else if (prop.PropertyType == typeof(DateTime) || prop.PropertyType == typeof(DateTime?))
            {
                if (DateTime.TryParse(value, out var dtVal))
                    convertedValue = dtVal;
            }
            else if (prop.PropertyType == typeof(bool) || prop.PropertyType == typeof(bool?))
            {
                if (bool.TryParse(value, out var boolVal))
                    convertedValue = boolVal;
            }
            
            if (convertedValue != null)
            {
                prop.SetValue(obj, convertedValue);
            }
        }
        catch
        {
            // Ignore conversion errors
        }
    }

    private async Task ExportToCsv()
    {
        if (_data == null || !_data.Any() || _tableMetadata == null)
        {
            Snackbar.Add("No data to export", Severity.Warning);
            return;
        }

        try
        {
            var csv = GenerateCsv(_data);
            var fileName = $"{_tableMetadata.TableName}_{DateTime.Now:yyyyMMdd_HHmmss}.csv";
            await DownloadFile(fileName, csv, "text/csv");
            Snackbar.Add($"Exported {_data.Count} records to {fileName}", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error exporting data: {ex.Message}", Severity.Error);
        }
    }

    private string GenerateCsv(List<object> data)
    {
        if (data == null || !data.Any()) return string.Empty;

        var properties = GetDisplayProperties();
        var csv = new StringBuilder();

        // Header row
        var headers = properties.Select(p => GetPropertyDisplayName(p));
        csv.AppendLine(string.Join(",", headers.Select(h => EscapeCsvField(h))));

        // Data rows
        foreach (var record in data)
        {
            var values = properties.Select(p =>
            {
                var value = GetPropertyValue(record, p.Name);
                return value?.ToString() ?? string.Empty;
            });
            csv.AppendLine(string.Join(",", values.Select(v => EscapeCsvField(v))));
        }

        return csv.ToString();
    }

    private string EscapeCsvField(string field)
    {
        if (string.IsNullOrEmpty(field)) return string.Empty;

        // If field contains comma, quote, or newline, wrap in quotes and escape quotes
        if (field.Contains(',') || field.Contains('"') || field.Contains('\n') || field.Contains('\r'))
        {
            return "\"" + field.Replace("\"", "\"\"") + "\"";
        }

        return field;
    }

    private async Task DownloadFile(string fileName, string content, string contentType)
    {
        var bytes = Encoding.UTF8.GetBytes(content);
        var base64 = Convert.ToBase64String(bytes);
        var dataUrl = $"data:{contentType};base64,{base64}";

        await JSRuntime.InvokeVoidAsync("downloadFile", fileName, dataUrl);
    }

    private async Task ShowImportDialog()
    {
        if (_tableMetadata == null)
        {
            Snackbar.Add("Please select a table first", Severity.Warning);
            return;
        }

        var parameters = new DialogParameters
        {
            ["TableName"] = _tableMetadata.TableName,
            ["TableMetadata"] = _tableMetadata
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Large,
            FullWidth = true
        };

        var dialog = await DialogService.ShowAsync<ImportCsvWizard>("Import CSV Wizard", parameters, options);
        var result = await dialog.Result;

        if (result != null && !result.Canceled)
        {
            await LoadData();
        }
    }

    // Foreign key cache
    private Dictionary<string, List<Dictionary<string, string>>> _foreignKeyCache = new();
    private Dictionary<string, List<KeyValuePair<string, string>>> _foreignKeyOptionsCache = new();

    private bool IsForeignKey(string propertyName)
    {
        if (_tableMetadata?.ForeignKeys == null) return false;
        return _tableMetadata.ForeignKeys.Any(fk => 
            fk.ForeignKeyColumn.Equals(propertyName, StringComparison.OrdinalIgnoreCase));
    }

    private PPDMForeignKey? GetForeignKeyInfo(string propertyName)
    {
        if (_tableMetadata?.ForeignKeys == null) return null;
        return _tableMetadata.ForeignKeys.FirstOrDefault(fk => 
            fk.ForeignKeyColumn.Equals(propertyName, StringComparison.OrdinalIgnoreCase));
    }

    private async Task PreloadForeignKeyOptions()
    {
        if (_tableMetadata?.ForeignKeys == null) return;

        _foreignKeyFieldOptions = new Dictionary<string, Dictionary<string, string>>();
        
        foreach (var fk in _tableMetadata.ForeignKeys)
        {
            var cacheKey = $"{fk.ReferencedTable}_{fk.ReferencedPrimaryKey}";
            if (!_foreignKeyOptionsCache.ContainsKey(cacheKey))
            {
                var options = await LoadForeignKeyOptions(fk);
                _foreignKeyOptionsCache[cacheKey] = options;
            }
            
            // Build field options dictionary for PPDMEntityForm
            var fieldOptions = new Dictionary<string, string>();
            if (_foreignKeyOptionsCache.ContainsKey(cacheKey))
            {
                foreach (var option in _foreignKeyOptionsCache[cacheKey])
                {
                    fieldOptions[option.Key] = option.Value;
                }
            }
            _foreignKeyFieldOptions[fk.ForeignKeyColumn] = fieldOptions;
        }
    }

    private async Task<List<KeyValuePair<string, string>>> LoadForeignKeyOptions(PPDMForeignKey fkInfo)
    {
        var cacheKey = $"{fkInfo.ReferencedTable}_{fkInfo.ReferencedPrimaryKey}";
        
        if (!_foreignKeyCache.ContainsKey(cacheKey))
        {
            try
            {
                var apiEndpoint = GetApiEndpoint(fkInfo.ReferencedTable);
                if (!string.IsNullOrEmpty(apiEndpoint))
                {
                    var data = await ApiClient.GetAsync<List<object>>($"/api/{apiEndpoint}");
                    if (data != null)
                    {
                        var options = new List<Dictionary<string, string>>();
                        foreach (var item in data)
                        {
                            var dict = new Dictionary<string, string>();
                            var props = item.GetType().GetProperties(BindingFlags.Public | BindingFlags.Instance);
                            foreach (var prop in props)
                            {
                                var value = prop.GetValue(item)?.ToString() ?? string.Empty;
                                dict[prop.Name] = value;
                            }
                            options.Add(dict);
                        }
                        _foreignKeyCache[cacheKey] = options;
                    }
                }
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Error loading options for {fkInfo.ReferencedTable}: {ex.Message}", Severity.Warning);
                _foreignKeyCache[cacheKey] = new List<Dictionary<string, string>>();
            }
        }

        var cachedData = _foreignKeyCache[cacheKey];
        var result = new List<KeyValuePair<string, string>>();

        foreach (var item in cachedData)
        {
            var pkValue = item.ContainsKey(fkInfo.ReferencedPrimaryKey) 
                ? item[fkInfo.ReferencedPrimaryKey] 
                : string.Empty;

            if (string.IsNullOrEmpty(pkValue)) continue;

            // Find name field (SHORT_NAME, LONG_NAME, NAME, etc.)
            var nameValue = GetNameValue(item);
            var displayText = !string.IsNullOrEmpty(nameValue) 
                ? $"{nameValue} ({pkValue})" 
                : pkValue;

            result.Add(new KeyValuePair<string, string>(pkValue, displayText));
        }

        return result.OrderBy(kvp => kvp.Value).ToList();
    }

    private string GetNameValue(Dictionary<string, string> item)
    {
        // Try common name fields in order of preference
        var nameFields = new[] { "SHORT_NAME", "LONG_NAME", "NAME", "STATUS", "DESCRIPTION" };
        
        foreach (var nameField in nameFields)
        {
            if (item.ContainsKey(nameField) && !string.IsNullOrWhiteSpace(item[nameField]))
            {
                return item[nameField];
            }
        }

        return string.Empty;
    }

    private string? GetDefaultValue(string propertyName)
    {
        // Map property names to default values
        var defaults = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase)
        {
            { "ACTIVE_IND", "Y" },
            { "ROW_QUALITY", "GOOD" },
            { "PREFERRED_IND", "N" },
            { "CERTIFIED_IND", "N" },
            { "HIERARCHY_TYPE", "PARENT_CHILD" },
            { "STRAT_COLUMN_TYPE", "STANDARD" },
            { "STRAT_TYPE", "LITHOSTRATIGRAPHIC" },
            { "STRAT_UNIT_TYPE", "FORMATION" },
            { "STRAT_STATUS", "VALID" },
            { "AREA_TYPE", "FIELD" },
            { "DEPTH_OUOM", "M" },
            { "PICK_DEPTH_OUOM", "M" },
            { "AZIMUTH_NORTH_TYPE", "TRUE_NORTH" },
            { "CONFORMITY_RELATIONSHIP", "CONFORMABLE" },
            { "STRAT_INTERPRET_METHOD", "LOG_INTERPRETATION" },
            { "PICK_QUALITY", "GOOD" },
            { "PICK_VERSION_TYPE", "CURRENT" },
            { "TVD_METHOD", "STANDARD" },
            { "SOURCE", "SYSTEM" }
        };

        return defaults.TryGetValue(propertyName, out var value) ? value : null;
    }

    private object? ConvertDefaultValue(string defaultValue, Type targetType)
    {
        if (string.IsNullOrEmpty(defaultValue))
        {
            var underlyingType = Nullable.GetUnderlyingType(targetType) ?? targetType;
            if (underlyingType.IsValueType && Nullable.GetUnderlyingType(targetType) == null)
                return Activator.CreateInstance(underlyingType);
            return null;
        }

        var underlying = Nullable.GetUnderlyingType(targetType) ?? targetType;

        if (underlying == typeof(string))
            return defaultValue;
        if (underlying == typeof(int))
            return int.TryParse(defaultValue, out var i) ? i : 0;
        if (underlying == typeof(bool))
            return defaultValue.Equals("Y", StringComparison.OrdinalIgnoreCase) ||
                   defaultValue.Equals("Yes", StringComparison.OrdinalIgnoreCase) ||
                   defaultValue.Equals("1", StringComparison.OrdinalIgnoreCase) ||
                   defaultValue.Equals("True", StringComparison.OrdinalIgnoreCase);

        return Convert.ChangeType(defaultValue, underlying, CultureInfo.InvariantCulture);
    }

    [Inject] IDialogService DialogService { get; set; } = null!;
    [Inject] ApiClient ApiClient { get; set; } = null!;
    [Inject] ISnackbar Snackbar { get; set; } = null!;
    [Inject] IJSRuntime JSRuntime { get; set; } = null!;
}
